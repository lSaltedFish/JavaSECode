

一、super关键字的使用
1. 为什么使用super？

举例1：子类继承父类之后，对父类方法进行了重写，那么在子类中，是否还可以对父类中被重写的方法进行调用？
可以

举例2：子类继承父类之后，发现子类和父类中定义了同名的属性，是否可以在子类中区分两个同名的属性？
可以

如何调用？使用super关键字即可。

2.super的理解：父类的

3.super可以调用的结构：属性、方法、构造器

具体的：
3.1  super调用属性、方法
    子类继承父类之后，我们就可以在子类的方法或构造器中，调用父类中声明的属性或方法。（满足封装性的前提下）
    如何调用？需要使用"super."的结构，表示调用父类的属性或方法。
    一般情况下，我们可以考虑省略"super."的结构。但是如果出现子类重写了父类的方法或子父类中出现同名的属性时，
    则必须使用"super."的声明，显式的调用父类被重新的方法或父类中声明的同名属性。

3.2  super调用构造器
    ① 子类继承父类时，不会继承父类的构造器。只能通过”super（形参列表）”的方式调用父类指定的构造器。
    ② 规定：“this（形参列表）”，必须声明在构造器的首行。
    ③ 在构造器首行可以使用“this（形参列表）”调用本类中重载的构造器，
       结合②，得出结论：在构造器的首行，“this（形参列表）”和”super（形参列表）”只能二选一。
    ④ 如果在子类构造器的首行既没有显式调用“this（形参列表）”，也没有显式”super（形参列表）”，
       则子类构造器默人调用”super（）”，即调用父类中空参的构造器。
    ⑤ 由③和④得到结论：子类的任何一个构造器中，要么会调用本类中重载的构造器，要么会调用父类的构造器。
       只能是这两种情况之一。
    ⑥ 有⑤得到：一个类中声明了n个构造器，最多有n-1个构造器使用了“this（形参列表），则剩下的那个一定使用”super（形参列表）。

   -->我们在通过子类的构造器构建对象时，一定会在调用子类构造器的过程中直接或者间接的调用到父类的构造器。
   也正因为调用过父类的构造器，我们才会将父类中声明的属性或方法加载到内存中，共子类对象使用。


二、子类对象实例化全过程

1.从结果的角度来看：体现为类的继承性

当我们创建子类对象后，子类对象就获取了其父类中声明的属性和方法，在权限允许的情况下，可以直接调用。

2.从过程的角度来看：

当我们通过子类的构造器创建对象时，子类的构造器一定会直接或间接调用其父类的构造器，
而其父类的构造器也会直接或间接调用到其父类的构造器，直到调用了Object类中的构造器为止。

正因为我们通过调用过子类所有的父类的构造器，所以我们就会将父类中声明的属性、方法加载到内存当中，供子类对象使用。

在创建子类对象的过程中一定会调用父类的构造器！！！

3.创建子类对象时，内存中到底有几个对象？
 就只有一个对象！即为当前new后面构造器对应的类的对象。
 父类相关的属性和方法只是在创建子类对象时加载到了内存当中供子类对象使用。